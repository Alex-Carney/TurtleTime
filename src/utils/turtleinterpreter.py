import turtle as tur
import lsystem as ls

def is_any_of(character, array):
    """
    Parameters
    ----------
    character : character
        Character being analyzed
    array : list[characters]
        The list being searched for character

    Returns
    -------
    boolean

    This is just a simple function to search a list for a certain character. It will eventually be used to allow
    users to map multiple characters to one movement (see below). The syntax is_any_of(character, array) should be read
    [if (character) is any of the elements in this (array)]. The arrays here are usually unsortable, since they are
    random characters specified by the user, which is why the search algorithm is linear.
    """
    for j in range(len(array)):
        if array[j] == character:
            return True
        else:
            return False

class TurtleInterpreter:
    def __init__(self,
                 sequence,
                 delta,
                 unit_length=5,
                 initial_heading=90,
                 forwards_draw_keys = ["F"],
                 forwards_jump_keys = ["f"],
                 left_keys = ["+"],
                 right_keys  = ["-"],
                 save_keys = ["["],
                 load_keys = ["]"],
                 pen_size = 2,
                 pen_color = "white",
                 background_color = "black",
                 animation = False
                 ):
        """
        Parameters
        ----------
        sequence : string
            Sequence generated by an L-system generator for the interpreter to read.
        delta : float
            Angle of a single left or right turn in degrees
        unit_length : int
            Length of a single forwards movement from a given heading in pixels
        initial_heading : flaot
            Angle at which the turtle begins drawing at
        forwards_draw_keys = ["F"] : list[characters]
            The keys directing a drawn forward movement
        forwards_jump_keys = ["f"] : list[characters]
            The keys directing an undrawn forward movement
        left_keys = ["+"] : list[characters]
            The keys directing a left turn from the current heading
        right_keys = ["-"] : list[characters]
            The keys directing a right turn from the current heading
        save_keys = ["["] : list[characters]
            The keys directing the interpreter to save the current position and heading (turtle state)
        load_keys = ["]"] : list[characters]
            The keys directing the interpreter to load the most recent position and heading (turtle state)
        pen_size = 2 : int
            Width of a turtle line in pixels
        pen_color = "white" : color specification string
            Color the turtle draws with
        background_color = "black" : color specification string
            Color of the canvas the turtle draws on
        animation = False : boolean
            Whether or not animation is enabled. Highly unrecommended since max turtle speed is rather slow.
        """

        self.sequence = sequence
        self.unit_length = unit_length
        self.delta = delta
        self.initial_heading = initial_heading

        self.forwards_draw_keys = forwards_draw_keys
        self.forwards_jump_keys = forwards_jump_keys
        self.left_keys = left_keys
        self.right_keys = right_keys
        self.save_keys = save_keys
        self.load_keys = load_keys

        self.pen_size = pen_size
        self.pen_color = pen_color
        self.background_color = background_color
        self.animation = animation

    def draw(self):
        """
        Parameters
        ----------
        None

        Returns
        -------
        None

        This function is where the turtle genuinely interprets and draws an L-system
        """

        # Instantiate Turtle
        t = tur.Turtle()

        # Screen options
        screen = tur.Screen()
        t.pensize(self.pen_size)
        t.pencolor(self.pen_color)
        tur.Screen().bgcolor(self.background_color)

        # Establish screen and set screen size based on unit length
        cansize = 3000 * self.unit_length
        tur.screensize(canvwidth=cansize, canvheight=cansize)

        if (self.animation):
            # Set animation speed to maximum when animation is enabled
            t.speed(0)
        else:
            # Disable animation.
            tur.tracer(0, 0)

        # Direct turtle to desired initial heading
        t.left(self.initial_heading)

        # Establish stack for saving and loading turtle states
        state_stack = []

        # Loop forwards through sequence and make movements based on user input
        for i in range(len(self.sequence)):
            if is_any_of(self.sequence[i], self.left_keys): # Reminder: this reads "if (self.sequence[i]) is any of the elements in (self.left_keys)"
                # Turn left from heading
                t.left(self.delta)
            elif is_any_of(self.sequence[i], self.right_keys):
                # Turn right from heading
                t.right(self.delta)
            elif is_any_of(self.sequence[i], self.forwards_draw_keys):
                # Move in the direction of heading and draw
                t.forward(self.unit_length)
            elif is_any_of(self.sequence[i], self.forwards_jump_keys):
                # Move in the direction of heading without drawing
                t.penup()
                t.forward(self.unit_length)
                t.pendown()
            elif is_any_of(self.sequence[i], self.save_keys):
                # Save the current state to the stack
                state_stack.append( (t.pos(), t.heading()) )
            elif is_any_of(self.sequence[i], self.load_keys):
                # Load the most recent state from the stack
                loaded_position, loaded_heading = state_stack.pop()
                t.penup()
                t.setpos(loaded_position)
                t.setheading(loaded_heading)
                t.pendown()

        # Leave screen open for animation or update and show screen
        if (self.animation):
            tur.getscreen()
            tur.mainloop()
        else:
            tur.update()
            tur.getscreen()

        # Close screen by clicking
        screen.exitonclick()




def main():


    ##################################################
    # EXAMPLE 1: COOL LOOKING TREE DESIGNED BY VINNY #
    ##################################################

    # Set the rules for generating a custom sequence (see L-system program)
    tree_productions = [
        ['X', ['', ''], [["0[+X[---X]]0[---X]+X", 1]]],
        ['0', ['', ''], [["00", 1]]],
        ['[', ['', ''], [["[", 1]]],
        [']', ['', ''], [["]", 1]]],
        ['+', ['', ''], [["+", 1]]],
        ['-', ['', ''], [["-", 1]]],
    ]
    # Establish the LSystem using Alex's method
    custom_system = ls.LSystem(['X', 'F'], 'X', tree_productions)
    custom_system_string = custom_system.l_string(6)
    # Instantiate the interpreter and draw the result. This was a tree I designed myself.
    tree = TurtleInterpreter(custom_system_string, 15, forwards_draw_keys=["0", "1"], unit_length=3)
    tree.draw()

    ##################################################
    # EXAMPLE 2: KOCH SNOWFLAKE                      #
    ##################################################

    # # Production list
    # koch_productions = [
    #     ['F', ['', ''], [["F-F++F-F", 1]]],
    #     ['+', ['', ''], [["+", 1]]],
    #     ['-', ['', ''], [["-", 1]]],
    # ]
    # # Establish the LSystem using Alex's method
    # custom_system = ls.LSystem([], 'F++F++F', koch_productions)
    # custom_system_string = custom_system.l_string(4)
    # # Instantiate the interpreter and draw the result. This was a tree I designed myself.
    # tree = TurtleInterpreter(custom_system_string, 60, unit_length=1, initial_heading=0)
    # tree.draw()




if __name__ == '__main__':
    main()